macOS Prerequisties
-------------------
* `brew install cmake`
* `brew install ninja`
* `brew install boost-python3`
* `brew install pybind11`

Linux Prerequisities
--------------------
* `conda install -c conda-forge cmake`
* `conda install -c conda-forge ninja`
* `conda install -c conda-forge boost`
* `conda install -c conda-forge pybind11`

Example CMake Command: `cmake -G Ninja -S src -B bld`  (if -GNinja is not specified then Makefiles are generated by default by CMake)


Build steps
===========
```
# Configure for Linux
$ cmake -GNinja -S../pybind-benchmarks/ -B../_build -DCMAKE_CXX_STANDARD=14 -DCMAKE_BUILD_TYPE=Debug -DPYTHON_EXECUTABLE=$CONDA_PREFIX/bin/python

# Configure for macOS
$ cmake -GNinja -S../pybind-benchmarks/ -B../_build -DCMAKE_CXX_STANDARD=14 -DCMAKE_BUILD_TYPE=Debug -DPYTHON_EXECUTABLE=$(brew --prefix)/bin/python3


# Building
$ cmake --build ../_build --target benchmark_pybind11
$ cmake --build ../_build --target benchmark_boost


# Test
$ PYTHONPATH=../_build $CONDA_PREFIX/bin/python benchmark.py
```


setup.py method
===============
Python bindings can also be compiled by specifying the extension modules in python package's `setup.py`.
The trick is to use `distutils.extension.Extension`.

See https://stackoverflow.com/a/21751764



Benchmarks[macOS]
=================
```
get_string_hash[pybind11] 5.546750928
get_string_hash[boost] 3.749171831000001
get_number_range[pybind11] 6.0434313
get_number_range[boost] 21.374577746
callback[pybind11] 12.154041348
callback[boost] 2.6870752499999995
```


Roadblocks with Boost.Python
----------------------------
* See @nwani's [answer](https://stackoverflow.com/a/61592909) pointing an issue in Boost.Python (if installed in conda environment) which should be resolved with Python 3.8
* There are some more problems related to Boost.Python installed in conda environment on macOS. See [issue](https://github.com/TNG/boost-python-examples#os-x-again-with-homebrew).
* Boost.Python has limited STL support. Also there were some trouble dealing with strings:
	- CentOS7 (gcc8cxx14, boost 1.71, python3.7):
```
>>> help(bp.get_string_hash)  # bp corresponds to boost python
Help on built-in function get_string_hash in module benchmark_boost:

get_string_hash(...)
    get_string_hash( (object)arg1) -> int :

        C++ signature :
            unsigned long get_string_hash(std::string)
```
	- macOS (clang11cxx14, boost 1.73, python3.8)
```
>>> help(bp.get_string_hash)  # bp corresponds to boost python
Help on built-in function get_string_hash in module benchmark_boost:

get_string_hash(...)
    get_string_hash( (str)arg1) -> int :

        C++ signature :
            unsigned long get_string_hash(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >)
```

	- The macOS variant works perfectly but the one on Linux throws an error (maybe because the generated signature doesn't have const string reference). Besides, shouldn't the generated signature be same agnostic of the platform?
```
Traceback (most recent call last):
  File "benchmark.py", line 15, in <module>
    number=1000000)))
  File "/root/miniconda3/envs/py37/lib/python3.7/timeit.py", line 233, in timeit
    return Timer(stmt, setup, timer, globals).timeit(number)
  File "/root/miniconda3/envs/py37/lib/python3.7/timeit.py", line 177, in timeit
    timing = self.inner(it, self.timer)
  File "<timeit-src>", line 6, in inner
  File "benchmark.py", line 14, in <lambda>
    lambda: benchmark_boost.get_string_hash('Hello World!' * 125),
Boost.Python.ArgumentError: Python argument types in
    benchmark_boost.get_string_hash(str)
did not match C++ signature:
    get_string_hash(std::string)
```
